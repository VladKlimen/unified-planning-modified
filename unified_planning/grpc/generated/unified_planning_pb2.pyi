"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _ExpressionKind:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _ExpressionKindEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_ExpressionKind.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    UNKNOWN: _ExpressionKind.ValueType  # 0
    """Default value, should not be used. Drop it if we are sure to never need it."""
    CONSTANT: _ExpressionKind.ValueType  # 1
    """Constant atom. For instance `3` or `kitchen` (where `kitchen` is an object defined in the problem)"""
    PARAMETER: _ExpressionKind.ValueType  # 2
    """Atom symbol representing a parameter from an outer scope. For instance `from` that would appear inside a `(move from to - location)` action."""
    VARIABLE: _ExpressionKind.ValueType  # 7
    """Atom symbol representing a variable from an outer scope.
    This is typically used to represent the variables that are existentially or universally qualified in expressions.
    """
    FLUENT_SYMBOL: _ExpressionKind.ValueType  # 3
    """Atom symbol representing a fluent of the problem. For instance `at-robot`."""
    FUNCTION_SYMBOL: _ExpressionKind.ValueType  # 4
    """Atom representing a function. For instance `+`, `=`, `and`, ..."""
    STATE_VARIABLE: _ExpressionKind.ValueType  # 5
    """List. Application of some parameters to a fluent symbol. For instance `(at-robot l1)` or `(battery-charged)`
    The first element of the list must be a FLUENT_SYMBOL
    """
    FUNCTION_APPLICATION: _ExpressionKind.ValueType  # 6
    """List. The expression is the application of some parameters to a function. For instance `(+ 1 3)`.
    The first element of the list must be a FUNCTION_SYMBOL
    """
    CONTAINER_ID: _ExpressionKind.ValueType  # 8
    """Atom symbol. Unique identifier of a task or action in the current scope."""

class ExpressionKind(_ExpressionKind, metaclass=_ExpressionKindEnumTypeWrapper):
    """The kind of an expression, which gives information related to its structure."""

UNKNOWN: ExpressionKind.ValueType  # 0
"""Default value, should not be used. Drop it if we are sure to never need it."""
CONSTANT: ExpressionKind.ValueType  # 1
"""Constant atom. For instance `3` or `kitchen` (where `kitchen` is an object defined in the problem)"""
PARAMETER: ExpressionKind.ValueType  # 2
"""Atom symbol representing a parameter from an outer scope. For instance `from` that would appear inside a `(move from to - location)` action."""
VARIABLE: ExpressionKind.ValueType  # 7
"""Atom symbol representing a variable from an outer scope.
This is typically used to represent the variables that are existentially or universally qualified in expressions.
"""
FLUENT_SYMBOL: ExpressionKind.ValueType  # 3
"""Atom symbol representing a fluent of the problem. For instance `at-robot`."""
FUNCTION_SYMBOL: ExpressionKind.ValueType  # 4
"""Atom representing a function. For instance `+`, `=`, `and`, ..."""
STATE_VARIABLE: ExpressionKind.ValueType  # 5
"""List. Application of some parameters to a fluent symbol. For instance `(at-robot l1)` or `(battery-charged)`
The first element of the list must be a FLUENT_SYMBOL
"""
FUNCTION_APPLICATION: ExpressionKind.ValueType  # 6
"""List. The expression is the application of some parameters to a function. For instance `(+ 1 3)`.
The first element of the list must be a FUNCTION_SYMBOL
"""
CONTAINER_ID: ExpressionKind.ValueType  # 8
"""Atom symbol. Unique identifier of a task or action in the current scope."""
global___ExpressionKind = ExpressionKind

class _Feature:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _FeatureEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Feature.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    ACTION_BASED: _Feature.ValueType  # 0
    """PROBLEM_CLASS"""
    HIERARCHICAL: _Feature.ValueType  # 26
    SIMPLE_NUMERIC_PLANNING: _Feature.ValueType  # 30
    """PROBLEM_TYPE"""
    GENERAL_NUMERIC_PLANNING: _Feature.ValueType  # 31
    CONTINUOUS_TIME: _Feature.ValueType  # 1
    """TIME"""
    DISCRETE_TIME: _Feature.ValueType  # 2
    INTERMEDIATE_CONDITIONS_AND_EFFECTS: _Feature.ValueType  # 3
    TIMED_EFFECT: _Feature.ValueType  # 4
    TIMED_GOALS: _Feature.ValueType  # 5
    DURATION_INEQUALITIES: _Feature.ValueType  # 6
    STATIC_FLUENTS_IN_DURATION: _Feature.ValueType  # 27
    """EXPRESSION_DURATION"""
    FLUENTS_IN_DURATION: _Feature.ValueType  # 28
    CONTINUOUS_NUMBERS: _Feature.ValueType  # 7
    """NUMBERS"""
    DISCRETE_NUMBERS: _Feature.ValueType  # 8
    NEGATIVE_CONDITIONS: _Feature.ValueType  # 9
    """CONDITIONS_KIND"""
    DISJUNCTIVE_CONDITIONS: _Feature.ValueType  # 10
    EQUALITY: _Feature.ValueType  # 11
    EXISTENTIAL_CONDITIONS: _Feature.ValueType  # 12
    UNIVERSAL_CONDITIONS: _Feature.ValueType  # 13
    CONDITIONAL_EFFECTS: _Feature.ValueType  # 14
    """EFFECTS_KIND"""
    INCREASE_EFFECTS: _Feature.ValueType  # 15
    DECREASE_EFFECTS: _Feature.ValueType  # 16
    FLAT_TYPING: _Feature.ValueType  # 17
    """TYPING"""
    HIERARCHICAL_TYPING: _Feature.ValueType  # 18
    NUMERIC_FLUENTS: _Feature.ValueType  # 19
    """FLUENTS_TYPE"""
    OBJECT_FLUENTS: _Feature.ValueType  # 20
    ACTIONS_COST: _Feature.ValueType  # 21
    """QUALITY_METRICS"""
    FINAL_VALUE: _Feature.ValueType  # 22
    MAKESPAN: _Feature.ValueType  # 23
    PLAN_LENGTH: _Feature.ValueType  # 24
    OVERSUBSCRIPTION: _Feature.ValueType  # 29
    SIMULATED_EFFECTS: _Feature.ValueType  # 25
    """SIMULATED_ENTITIES"""

class Feature(_Feature, metaclass=_FeatureEnumTypeWrapper):
    """Features of the problem.
    Features are essential in that not supporting a feature `X` should allow disregarding any field tagged with `features: [X]`.
    """

ACTION_BASED: Feature.ValueType  # 0
"""PROBLEM_CLASS"""
HIERARCHICAL: Feature.ValueType  # 26
SIMPLE_NUMERIC_PLANNING: Feature.ValueType  # 30
"""PROBLEM_TYPE"""
GENERAL_NUMERIC_PLANNING: Feature.ValueType  # 31
CONTINUOUS_TIME: Feature.ValueType  # 1
"""TIME"""
DISCRETE_TIME: Feature.ValueType  # 2
INTERMEDIATE_CONDITIONS_AND_EFFECTS: Feature.ValueType  # 3
TIMED_EFFECT: Feature.ValueType  # 4
TIMED_GOALS: Feature.ValueType  # 5
DURATION_INEQUALITIES: Feature.ValueType  # 6
STATIC_FLUENTS_IN_DURATION: Feature.ValueType  # 27
"""EXPRESSION_DURATION"""
FLUENTS_IN_DURATION: Feature.ValueType  # 28
CONTINUOUS_NUMBERS: Feature.ValueType  # 7
"""NUMBERS"""
DISCRETE_NUMBERS: Feature.ValueType  # 8
NEGATIVE_CONDITIONS: Feature.ValueType  # 9
"""CONDITIONS_KIND"""
DISJUNCTIVE_CONDITIONS: Feature.ValueType  # 10
EQUALITY: Feature.ValueType  # 11
EXISTENTIAL_CONDITIONS: Feature.ValueType  # 12
UNIVERSAL_CONDITIONS: Feature.ValueType  # 13
CONDITIONAL_EFFECTS: Feature.ValueType  # 14
"""EFFECTS_KIND"""
INCREASE_EFFECTS: Feature.ValueType  # 15
DECREASE_EFFECTS: Feature.ValueType  # 16
FLAT_TYPING: Feature.ValueType  # 17
"""TYPING"""
HIERARCHICAL_TYPING: Feature.ValueType  # 18
NUMERIC_FLUENTS: Feature.ValueType  # 19
"""FLUENTS_TYPE"""
OBJECT_FLUENTS: Feature.ValueType  # 20
ACTIONS_COST: Feature.ValueType  # 21
"""QUALITY_METRICS"""
FINAL_VALUE: Feature.ValueType  # 22
MAKESPAN: Feature.ValueType  # 23
PLAN_LENGTH: Feature.ValueType  # 24
OVERSUBSCRIPTION: Feature.ValueType  # 29
SIMULATED_EFFECTS: Feature.ValueType  # 25
"""SIMULATED_ENTITIES"""
global___Feature = Feature

@typing_extensions.final
class Expression(google.protobuf.message.Message):
    """================== Expressions ====================

    As in s-expression, an Expression is either an atom or list representing the application of some parameters to a function/fluent.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ATOM_FIELD_NUMBER: builtins.int
    LIST_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    KIND_FIELD_NUMBER: builtins.int
    @property
    def atom(self) -> global___Atom:
        """If non-empty, the expression is a single atom.
        For instance `3`, `+`, `kitchen`, `at-robot`, ...
        """
    @property
    def list(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Expression]:
        """If the `atom` field is empty, then the expression is a list of sub-expressions,
        typically representing the application of some arguments to a function or fluent.
        For instance `(+ 1 3)`, (at-robot l1)`, `(>= (battery_level) 20)`
        """
    type: builtins.str
    """Type of the expression. For instance "int", "location", ..."""
    kind: global___ExpressionKind.ValueType
    """Kind of the expression, specifying the content of the expression.
    This is intended to facilitate parsing of the expression.
    """
    def __init__(
        self,
        *,
        atom: global___Atom | None = ...,
        list: collections.abc.Iterable[global___Expression] | None = ...,
        type: builtins.str = ...,
        kind: global___ExpressionKind.ValueType = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["atom", b"atom"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["atom", b"atom", "kind", b"kind", "list", b"list", "type", b"type"]) -> None: ...

global___Expression = Expression

@typing_extensions.final
class Atom(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SYMBOL_FIELD_NUMBER: builtins.int
    INT_FIELD_NUMBER: builtins.int
    REAL_FIELD_NUMBER: builtins.int
    BOOLEAN_FIELD_NUMBER: builtins.int
    symbol: builtins.str
    int: builtins.int
    @property
    def real(self) -> global___Real: ...
    boolean: builtins.bool
    def __init__(
        self,
        *,
        symbol: builtins.str = ...,
        int: builtins.int = ...,
        real: global___Real | None = ...,
        boolean: builtins.bool = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["boolean", b"boolean", "content", b"content", "int", b"int", "real", b"real", "symbol", b"symbol"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["boolean", b"boolean", "content", b"content", "int", b"int", "real", b"real", "symbol", b"symbol"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["content", b"content"]) -> typing_extensions.Literal["symbol", "int", "real", "boolean"] | None: ...

global___Atom = Atom

@typing_extensions.final
class Real(google.protobuf.message.Message):
    """Representation of a constant real number, as the fraction `(numerator / denominator)`.
    A real should be in its canonical form (with smallest possible denominator).
    Notably, if this number is an integer, then it is guaranteed that `denominator == 1`.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NUMERATOR_FIELD_NUMBER: builtins.int
    DENOMINATOR_FIELD_NUMBER: builtins.int
    numerator: builtins.int
    denominator: builtins.int
    def __init__(
        self,
        *,
        numerator: builtins.int = ...,
        denominator: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["denominator", b"denominator", "numerator", b"numerator"]) -> None: ...

global___Real = Real

@typing_extensions.final
class TypeDeclaration(google.protobuf.message.Message):
    """============= Domains ====================

    Declares the existence of a symbolic type.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TYPE_NAME_FIELD_NUMBER: builtins.int
    PARENT_TYPE_FIELD_NUMBER: builtins.int
    type_name: builtins.str
    """Name of the type that is declared."""
    parent_type: builtins.str
    """Optional. If the string is non-empty, this is the parent type of `type_name`.
    If set, the parent type must have been previously declared (i.e. should appear earlier in the problem's type declarations.
    feature: HIERARCHICAL_TYPING
    """
    def __init__(
        self,
        *,
        type_name: builtins.str = ...,
        parent_type: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["parent_type", b"parent_type", "type_name", b"type_name"]) -> None: ...

global___TypeDeclaration = TypeDeclaration

@typing_extensions.final
class Parameter(google.protobuf.message.Message):
    """Parameter of a fluent or of an action"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NAME_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    name: builtins.str
    """Name of the parameter."""
    type: builtins.str
    """Type of the parameter."""
    def __init__(
        self,
        *,
        name: builtins.str = ...,
        type: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["name", b"name", "type", b"type"]) -> None: ...

global___Parameter = Parameter

@typing_extensions.final
class Fluent(google.protobuf.message.Message):
    """A state-dependent variable."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NAME_FIELD_NUMBER: builtins.int
    VALUE_TYPE_FIELD_NUMBER: builtins.int
    PARAMETERS_FIELD_NUMBER: builtins.int
    DEFAULT_VALUE_FIELD_NUMBER: builtins.int
    name: builtins.str
    value_type: builtins.str
    """Return type of the fluent."""
    @property
    def parameters(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Parameter]:
        """Typed and named parameters of the fluent."""
    @property
    def default_value(self) -> global___Expression:
        """If non-empty, then any state variable using this fluent that is not explicitly given a value in the initial state
        will be assumed to have this default value.
        This allows mimicking the closed world assumption by setting a "false" default value to predicates.
        Note that in the initial state of the problem message, it is assumed that all default values are set.
        """
    def __init__(
        self,
        *,
        name: builtins.str = ...,
        value_type: builtins.str = ...,
        parameters: collections.abc.Iterable[global___Parameter] | None = ...,
        default_value: global___Expression | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["default_value", b"default_value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["default_value", b"default_value", "name", b"name", "parameters", b"parameters", "value_type", b"value_type"]) -> None: ...

global___Fluent = Fluent

@typing_extensions.final
class ObjectDeclaration(google.protobuf.message.Message):
    """Declares an object with the given name and type."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NAME_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    name: builtins.str
    """Name of the object."""
    type: builtins.str
    """Type of the object.
    The type must have been previously declared in the problem definition.
    """
    def __init__(
        self,
        *,
        name: builtins.str = ...,
        type: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["name", b"name", "type", b"type"]) -> None: ...

global___ObjectDeclaration = ObjectDeclaration

@typing_extensions.final
class EffectExpression(google.protobuf.message.Message):
    """========= Actions ========

    An effect expression is of the form `FLUENT OP VALUE`.
    We explicitly restrict the different types of effects by setting the allowed operators.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _EffectKind:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _EffectKindEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[EffectExpression._EffectKind.ValueType], builtins.type):  # noqa: F821
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        ASSIGN: EffectExpression._EffectKind.ValueType  # 0
        """The `fluent` is set to the corresponding `value`"""
        INCREASE: EffectExpression._EffectKind.ValueType  # 1
        """The `fluent` is increased by the amount `value`
        features: INCREASE_EFFECTS
        """
        DECREASE: EffectExpression._EffectKind.ValueType  # 2
        """The `fluent` is decreased by the amount `value`
        features: DECREASE_EFFECTS
        """

    class EffectKind(_EffectKind, metaclass=_EffectKindEnumTypeWrapper): ...
    ASSIGN: EffectExpression.EffectKind.ValueType  # 0
    """The `fluent` is set to the corresponding `value`"""
    INCREASE: EffectExpression.EffectKind.ValueType  # 1
    """The `fluent` is increased by the amount `value`
    features: INCREASE_EFFECTS
    """
    DECREASE: EffectExpression.EffectKind.ValueType  # 2
    """The `fluent` is decreased by the amount `value`
    features: DECREASE_EFFECTS
    """

    KIND_FIELD_NUMBER: builtins.int
    FLUENT_FIELD_NUMBER: builtins.int
    VALUE_FIELD_NUMBER: builtins.int
    CONDITION_FIELD_NUMBER: builtins.int
    kind: global___EffectExpression.EffectKind.ValueType
    @property
    def fluent(self) -> global___Expression:
        """Expression that must be of the STATE_VARIABLE kind."""
    @property
    def value(self) -> global___Expression: ...
    @property
    def condition(self) -> global___Expression:
        """Optional. If the effect is conditional, then the following field must be set.
        In this case, the `effect` will only be applied if the `condition`` holds.
        If the effect is unconditional, the effect is set to the constant 'true' value.
        features: CONDITIONAL_EFFECT
        """
    def __init__(
        self,
        *,
        kind: global___EffectExpression.EffectKind.ValueType = ...,
        fluent: global___Expression | None = ...,
        value: global___Expression | None = ...,
        condition: global___Expression | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["condition", b"condition", "fluent", b"fluent", "value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["condition", b"condition", "fluent", b"fluent", "kind", b"kind", "value", b"value"]) -> None: ...

global___EffectExpression = EffectExpression

@typing_extensions.final
class Effect(google.protobuf.message.Message):
    """Representation of an effect that allows qualifying the effect expression, e.g., to make it a conditional effect."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    EFFECT_FIELD_NUMBER: builtins.int
    OCCURRENCE_TIME_FIELD_NUMBER: builtins.int
    @property
    def effect(self) -> global___EffectExpression:
        """Required. The actual effect that should take place."""
    @property
    def occurrence_time(self) -> global___Timing:
        """Optional. If the effect is within a durative action, the following must be set and will specify when the effect takes place.
        features: DURATIVE_ACTIONS
        """
    def __init__(
        self,
        *,
        effect: global___EffectExpression | None = ...,
        occurrence_time: global___Timing | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["effect", b"effect", "occurrence_time", b"occurrence_time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["effect", b"effect", "occurrence_time", b"occurrence_time"]) -> None: ...

global___Effect = Effect

@typing_extensions.final
class Condition(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    COND_FIELD_NUMBER: builtins.int
    SPAN_FIELD_NUMBER: builtins.int
    @property
    def cond(self) -> global___Expression: ...
    @property
    def span(self) -> global___TimeInterval:
        """Optional. Must be set for durative actions where it specifies the temporal interval
        over which when the condition should hold.
        features: DURATIVE_ACTIONS
        """
    def __init__(
        self,
        *,
        cond: global___Expression | None = ...,
        span: global___TimeInterval | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["cond", b"cond", "span", b"span"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["cond", b"cond", "span", b"span"]) -> None: ...

global___Condition = Condition

@typing_extensions.final
class Action(google.protobuf.message.Message):
    """Unified action representation that represents any kind of actions."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NAME_FIELD_NUMBER: builtins.int
    PARAMETERS_FIELD_NUMBER: builtins.int
    DURATION_FIELD_NUMBER: builtins.int
    CONDITIONS_FIELD_NUMBER: builtins.int
    EFFECTS_FIELD_NUMBER: builtins.int
    name: builtins.str
    """Action name. E.g. "move" """
    @property
    def parameters(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Parameter]:
        """Typed and named parameters of the action."""
    @property
    def duration(self) -> global___Duration:
        """If set, the action is durative. Otherwise it is instantaneous.
        features: DURATIVE_ACTIONS
        """
    @property
    def conditions(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Condition]:
        """Conjunction of conditions that must hold for the action to be applicable."""
    @property
    def effects(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Effect]:
        """Conjunction of effects as a result of applying this action."""
    def __init__(
        self,
        *,
        name: builtins.str = ...,
        parameters: collections.abc.Iterable[global___Parameter] | None = ...,
        duration: global___Duration | None = ...,
        conditions: collections.abc.Iterable[global___Condition] | None = ...,
        effects: collections.abc.Iterable[global___Effect] | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["duration", b"duration"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["conditions", b"conditions", "duration", b"duration", "effects", b"effects", "name", b"name", "parameters", b"parameters"]) -> None: ...

global___Action = Action

@typing_extensions.final
class Timepoint(google.protobuf.message.Message):
    """Symbolic reference to an absolute time.
    It might represent:
    - the time of the initial/final state, or
    - the start/end of the containing action.

    It is currently composed of a single field whose interpretation might be context dependent
    (e.g. "START" refers to the start of the containing action).

    In the future, it could be extended to refer, e.g., to the start of a particular action/subtask
    by adding an additional field with the identifier of an action/subtask.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _TimepointKind:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _TimepointKindEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[Timepoint._TimepointKind.ValueType], builtins.type):  # noqa: F821
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        GLOBAL_START: Timepoint._TimepointKind.ValueType  # 0
        """Global start of the planning problem. This is context independent and represents the time at which the initial state holds."""
        GLOBAL_END: Timepoint._TimepointKind.ValueType  # 1
        """Global end of the planning problem. This is context independent and represents the time at which the final state holds."""
        START: Timepoint._TimepointKind.ValueType  # 2
        """Start of the container (typically the action or method) in which this symbol occurs"""
        END: Timepoint._TimepointKind.ValueType  # 3
        """End of the container (typically the action or method) in which this symbol occurs"""

    class TimepointKind(_TimepointKind, metaclass=_TimepointKindEnumTypeWrapper): ...
    GLOBAL_START: Timepoint.TimepointKind.ValueType  # 0
    """Global start of the planning problem. This is context independent and represents the time at which the initial state holds."""
    GLOBAL_END: Timepoint.TimepointKind.ValueType  # 1
    """Global end of the planning problem. This is context independent and represents the time at which the final state holds."""
    START: Timepoint.TimepointKind.ValueType  # 2
    """Start of the container (typically the action or method) in which this symbol occurs"""
    END: Timepoint.TimepointKind.ValueType  # 3
    """End of the container (typically the action or method) in which this symbol occurs"""

    KIND_FIELD_NUMBER: builtins.int
    CONTAINER_ID_FIELD_NUMBER: builtins.int
    kind: global___Timepoint.TimepointKind.ValueType
    container_id: builtins.str
    """If non-empty, identifies the container of which we are extracting the start/end timepoint.
    In the context of a task-network or of a method, this could be the `id` of one of the subtasks.
    feature: hierarchies
    """
    def __init__(
        self,
        *,
        kind: global___Timepoint.TimepointKind.ValueType = ...,
        container_id: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["container_id", b"container_id", "kind", b"kind"]) -> None: ...

global___Timepoint = Timepoint

@typing_extensions.final
class Timing(google.protobuf.message.Message):
    """Represents a time (`timepoint` + `delay`), that is a time defined relatively to a particular `timepoint`.
    Note that an absolute time can be defined by setting the `delay` relative to the `GLOBAL_START`` which is the reference time.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TIMEPOINT_FIELD_NUMBER: builtins.int
    DELAY_FIELD_NUMBER: builtins.int
    @property
    def timepoint(self) -> global___Timepoint: ...
    @property
    def delay(self) -> global___Real: ...
    def __init__(
        self,
        *,
        timepoint: global___Timepoint | None = ...,
        delay: global___Real | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["delay", b"delay", "timepoint", b"timepoint"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["delay", b"delay", "timepoint", b"timepoint"]) -> None: ...

global___Timing = Timing

@typing_extensions.final
class Interval(google.protobuf.message.Message):
    """An interval `[lower, upper]` where `lower` and `upper` are arbitrary expressions.
    The `is_left_open` and `is_right_open` fields indicate whether the interval is
    opened on left and right side respectively.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    IS_LEFT_OPEN_FIELD_NUMBER: builtins.int
    LOWER_FIELD_NUMBER: builtins.int
    IS_RIGHT_OPEN_FIELD_NUMBER: builtins.int
    UPPER_FIELD_NUMBER: builtins.int
    is_left_open: builtins.bool
    @property
    def lower(self) -> global___Expression: ...
    is_right_open: builtins.bool
    @property
    def upper(self) -> global___Expression: ...
    def __init__(
        self,
        *,
        is_left_open: builtins.bool = ...,
        lower: global___Expression | None = ...,
        is_right_open: builtins.bool = ...,
        upper: global___Expression | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["lower", b"lower", "upper", b"upper"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["is_left_open", b"is_left_open", "is_right_open", b"is_right_open", "lower", b"lower", "upper", b"upper"]) -> None: ...

global___Interval = Interval

@typing_extensions.final
class TimeInterval(google.protobuf.message.Message):
    """A contiguous slice of time represented as an interval `[lower, upper]` where `lower` and `upper` are time references.
    The `is_left_open` and `is_right_open` fields indicate whether the interval is
    opened on left and right side respectively.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    IS_LEFT_OPEN_FIELD_NUMBER: builtins.int
    LOWER_FIELD_NUMBER: builtins.int
    IS_RIGHT_OPEN_FIELD_NUMBER: builtins.int
    UPPER_FIELD_NUMBER: builtins.int
    is_left_open: builtins.bool
    @property
    def lower(self) -> global___Timing: ...
    is_right_open: builtins.bool
    @property
    def upper(self) -> global___Timing: ...
    def __init__(
        self,
        *,
        is_left_open: builtins.bool = ...,
        lower: global___Timing | None = ...,
        is_right_open: builtins.bool = ...,
        upper: global___Timing | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["lower", b"lower", "upper", b"upper"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["is_left_open", b"is_left_open", "is_right_open", b"is_right_open", "lower", b"lower", "upper", b"upper"]) -> None: ...

global___TimeInterval = TimeInterval

@typing_extensions.final
class Duration(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    CONTROLLABLE_IN_BOUNDS_FIELD_NUMBER: builtins.int
    @property
    def controllable_in_bounds(self) -> global___Interval:
        """/ The duration of the action can be freely chosen within the indicated bounds"""
    def __init__(
        self,
        *,
        controllable_in_bounds: global___Interval | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["controllable_in_bounds", b"controllable_in_bounds"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["controllable_in_bounds", b"controllable_in_bounds"]) -> None: ...

global___Duration = Duration

@typing_extensions.final
class AbstractTaskDeclaration(google.protobuf.message.Message):
    """============== Hierarchies ====================

    Declares an abstract task together with its expected parameters.

    Example: goto(robot: Robot, destination: Location)
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NAME_FIELD_NUMBER: builtins.int
    PARAMETERS_FIELD_NUMBER: builtins.int
    name: builtins.str
    """Example: "goto" """
    @property
    def parameters(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Parameter]:
        """Example:
         - robot: Robot
         - destination: Location
        """
    def __init__(
        self,
        *,
        name: builtins.str = ...,
        parameters: collections.abc.Iterable[global___Parameter] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["name", b"name", "parameters", b"parameters"]) -> None: ...

global___AbstractTaskDeclaration = AbstractTaskDeclaration

@typing_extensions.final
class Task(google.protobuf.message.Message):
    """Representation of an abstract or primitive task that should be achieved,
    required either in the initial task network or as a subtask of a method.

    Example:  task of sending a `robot` to the KITCHEN
      - t1: goto(robot, KITCHEN)
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ID_FIELD_NUMBER: builtins.int
    TASK_NAME_FIELD_NUMBER: builtins.int
    PARAMETERS_FIELD_NUMBER: builtins.int
    id: builtins.str
    """Identifier of the task, required to be unique in the method/task-network where the task appears.
    The `id` is notably used to refer to the start/end of the task.

    Example: t1
    """
    task_name: builtins.str
    """Name of the task that should be achieved. It might either
     - an abstract task if the name is the one of a task declared in the problem
     - a primitive task if the name is the one of an action declared in the problem

    Example:
     - "goto" (abstract task)
     - "move" (action / primitive task)
    """
    @property
    def parameters(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Expression]:
        """Example: (for a "goto" task)
         - robot    (a parameter from an outer scope)
         - KITCHEN  (a constant symbol in the problem)
        """
    def __init__(
        self,
        *,
        id: builtins.str = ...,
        task_name: builtins.str = ...,
        parameters: collections.abc.Iterable[global___Expression] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["id", b"id", "parameters", b"parameters", "task_name", b"task_name"]) -> None: ...

global___Task = Task

@typing_extensions.final
class Method(google.protobuf.message.Message):
    """A method describes one possible way of achieving a task.

    Example: A method that make a "move" action and recursively calls itself until reaching the destination.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NAME_FIELD_NUMBER: builtins.int
    PARAMETERS_FIELD_NUMBER: builtins.int
    ACHIEVED_TASK_FIELD_NUMBER: builtins.int
    SUBTASKS_FIELD_NUMBER: builtins.int
    CONSTRAINTS_FIELD_NUMBER: builtins.int
    CONDITIONS_FIELD_NUMBER: builtins.int
    name: builtins.str
    """A name that uniquely identify the method.
    This is mostly used for user facing output or plan validation.

    Example: "m-recursive-goto"
    """
    @property
    def parameters(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Parameter]:
        """Example: [robot: Robot, source: Location, intermediate: Location, destination: Location]"""
    @property
    def achieved_task(self) -> global___Task:
        """The task that is achieved by the method.
        A subset of the parameters of the method will typically be used to
        define the task that is achieved.

        Example: goto(robot, destination)
        """
    @property
    def subtasks(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Task]:
        """A set of subtasks that should be achieved to carry out the method.
        Note that the order of subtasks is irrelevant and that any ordering constraint should be
        specified in the `constraints` field.

        Example:
         - t1: (move robot source intermediate)
         - t2: goto(robot destination)
        """
    @property
    def constraints(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Expression]:
        """Constraints enable the definition of ordering constraints as well as constraints
        on the allowed instantiation of the method's parameters.

        Example:
         - end(t1) < start(t2)
         - source != intermediate
        """
    @property
    def conditions(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Condition]:
        """Conjunction of conditions that must hold for the method to be applicable.
        As for the conditions of actions, these can be temporally qualified to refer to intermediate timepoints.
        In addition to the start/end of the method, the temporal qualification might refer to the start/end of
        one of the subtasks using its identifier.

        Example:
         - [start] loc(robot) == source
         - [end(t1)] loc(robot) == intermediate
         - [end] loc(robot) == destination
        """
    def __init__(
        self,
        *,
        name: builtins.str = ...,
        parameters: collections.abc.Iterable[global___Parameter] | None = ...,
        achieved_task: global___Task | None = ...,
        subtasks: collections.abc.Iterable[global___Task] | None = ...,
        constraints: collections.abc.Iterable[global___Expression] | None = ...,
        conditions: collections.abc.Iterable[global___Condition] | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["achieved_task", b"achieved_task"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["achieved_task", b"achieved_task", "conditions", b"conditions", "constraints", b"constraints", "name", b"name", "parameters", b"parameters", "subtasks", b"subtasks"]) -> None: ...

global___Method = Method

@typing_extensions.final
class TaskNetwork(google.protobuf.message.Message):
    """A task network defines a set of subtasks and associated constraints.
    It is intended to be used to define the initial task network of the hierarchical problem.

    Example: an arbitrary robot should go to the KITCHEN before time 100
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VARIABLES_FIELD_NUMBER: builtins.int
    SUBTASKS_FIELD_NUMBER: builtins.int
    CONSTRAINTS_FIELD_NUMBER: builtins.int
    @property
    def variables(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Parameter]:
        """robot: Location"""
    @property
    def subtasks(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Task]:
        """t1: goto(robot, KITCHEN)"""
    @property
    def constraints(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Expression]:
        """end(t1) <= 100"""
    def __init__(
        self,
        *,
        variables: collections.abc.Iterable[global___Parameter] | None = ...,
        subtasks: collections.abc.Iterable[global___Task] | None = ...,
        constraints: collections.abc.Iterable[global___Expression] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["constraints", b"constraints", "subtasks", b"subtasks", "variables", b"variables"]) -> None: ...

global___TaskNetwork = TaskNetwork

@typing_extensions.final
class Hierarchy(google.protobuf.message.Message):
    """Represents the hierarchical part of a problem.
    features: hierarchical
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ABSTRACT_TASKS_FIELD_NUMBER: builtins.int
    METHODS_FIELD_NUMBER: builtins.int
    INITIAL_TASK_NETWORK_FIELD_NUMBER: builtins.int
    @property
    def abstract_tasks(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___AbstractTaskDeclaration]: ...
    @property
    def methods(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Method]: ...
    @property
    def initial_task_network(self) -> global___TaskNetwork: ...
    def __init__(
        self,
        *,
        abstract_tasks: collections.abc.Iterable[global___AbstractTaskDeclaration] | None = ...,
        methods: collections.abc.Iterable[global___Method] | None = ...,
        initial_task_network: global___TaskNetwork | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["initial_task_network", b"initial_task_network"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["abstract_tasks", b"abstract_tasks", "initial_task_network", b"initial_task_network", "methods", b"methods"]) -> None: ...

global___Hierarchy = Hierarchy

@typing_extensions.final
class Goal(google.protobuf.message.Message):
    """============== Problem =========================

    A Goal is currently an expression that must hold either:
    - in the final state,
    - over a specific temporal interval (under the `timed_goals` features)
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    GOAL_FIELD_NUMBER: builtins.int
    TIMING_FIELD_NUMBER: builtins.int
    @property
    def goal(self) -> global___Expression:
        """Goal expression that must hold in the final state."""
    @property
    def timing(self) -> global___TimeInterval:
        """Optional. If specified the goal should hold over the specified temporal interval (instead of on the final state).
        features: TIMED_GOALS
        """
    def __init__(
        self,
        *,
        goal: global___Expression | None = ...,
        timing: global___TimeInterval | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["goal", b"goal", "timing", b"timing"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["goal", b"goal", "timing", b"timing"]) -> None: ...

global___Goal = Goal

@typing_extensions.final
class TimedEffect(google.protobuf.message.Message):
    """Represents an effect that will occur sometime beyond the initial state. (similar to timed initial literals)"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    EFFECT_FIELD_NUMBER: builtins.int
    OCCURRENCE_TIME_FIELD_NUMBER: builtins.int
    @property
    def effect(self) -> global___EffectExpression:
        """Required. An effect expression that will take place sometime in the future (i.e. not at the intial state) as specified by the temporal qualifiation."""
    @property
    def occurrence_time(self) -> global___Timing:
        """Required. Temporal qualification denoting when the timed fact will occur."""
    def __init__(
        self,
        *,
        effect: global___EffectExpression | None = ...,
        occurrence_time: global___Timing | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["effect", b"effect", "occurrence_time", b"occurrence_time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["effect", b"effect", "occurrence_time", b"occurrence_time"]) -> None: ...

global___TimedEffect = TimedEffect

@typing_extensions.final
class Assignment(google.protobuf.message.Message):
    """An assignment of a value to a fluent, as it appears in the initial state definition."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    FLUENT_FIELD_NUMBER: builtins.int
    VALUE_FIELD_NUMBER: builtins.int
    @property
    def fluent(self) -> global___Expression:
        """State variable that is assigned the `value`.
        It should be an expression of the STATE_VARIABLE kind for which all parameters are of the CONSTANT kind.
        """
    @property
    def value(self) -> global___Expression:
        """An expression of the CONSTANT kind, denoting the value take by the state variable."""
    def __init__(
        self,
        *,
        fluent: global___Expression | None = ...,
        value: global___Expression | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["fluent", b"fluent", "value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["fluent", b"fluent", "value", b"value"]) -> None: ...

global___Assignment = Assignment

@typing_extensions.final
class GoalWithCost(google.protobuf.message.Message):
    """Represents a goal associated with a cost, used to define oversubscription planning."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    GOAL_FIELD_NUMBER: builtins.int
    COST_FIELD_NUMBER: builtins.int
    @property
    def goal(self) -> global___Expression:
        """Goal expression"""
    @property
    def cost(self) -> global___Real:
        """The cost"""
    def __init__(
        self,
        *,
        goal: global___Expression | None = ...,
        cost: global___Real | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["cost", b"cost", "goal", b"goal"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["cost", b"cost", "goal", b"goal"]) -> None: ...

global___GoalWithCost = GoalWithCost

@typing_extensions.final
class TimedGoalWithCost(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    GOAL_FIELD_NUMBER: builtins.int
    TIMING_FIELD_NUMBER: builtins.int
    COST_FIELD_NUMBER: builtins.int
    @property
    def goal(self) -> global___Expression:
        """Goal expression"""
    @property
    def timing(self) -> global___TimeInterval:
        """The time interval"""
    @property
    def cost(self) -> global___Real:
        """The cost"""
    def __init__(
        self,
        *,
        goal: global___Expression | None = ...,
        timing: global___TimeInterval | None = ...,
        cost: global___Real | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["cost", b"cost", "goal", b"goal", "timing", b"timing"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["cost", b"cost", "goal", b"goal", "timing", b"timing"]) -> None: ...

global___TimedGoalWithCost = TimedGoalWithCost

@typing_extensions.final
class Metric(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _MetricKind:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _MetricKindEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[Metric._MetricKind.ValueType], builtins.type):  # noqa: F821
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        MINIMIZE_ACTION_COSTS: Metric._MetricKind.ValueType  # 0
        """Minimize the action costs expressed in the `action_costs` field"""
        MINIMIZE_SEQUENTIAL_PLAN_LENGTH: Metric._MetricKind.ValueType  # 1
        """Minimize the length of the resulting sequential plan"""
        MINIMIZE_MAKESPAN: Metric._MetricKind.ValueType  # 2
        """Minimize the makespan in case of temporal planning
        features: durative_actions
        """
        MINIMIZE_EXPRESSION_ON_FINAL_STATE: Metric._MetricKind.ValueType  # 3
        """Minimize the value of the expression defined in the `expression` field"""
        MAXIMIZE_EXPRESSION_ON_FINAL_STATE: Metric._MetricKind.ValueType  # 4
        """Maximize the value of the expression defined in the `expression` field"""
        OVERSUBSCRIPTION: Metric._MetricKind.ValueType  # 5
        """Maximize the number of goals reached, weighted by cost"""

    class MetricKind(_MetricKind, metaclass=_MetricKindEnumTypeWrapper): ...
    MINIMIZE_ACTION_COSTS: Metric.MetricKind.ValueType  # 0
    """Minimize the action costs expressed in the `action_costs` field"""
    MINIMIZE_SEQUENTIAL_PLAN_LENGTH: Metric.MetricKind.ValueType  # 1
    """Minimize the length of the resulting sequential plan"""
    MINIMIZE_MAKESPAN: Metric.MetricKind.ValueType  # 2
    """Minimize the makespan in case of temporal planning
    features: durative_actions
    """
    MINIMIZE_EXPRESSION_ON_FINAL_STATE: Metric.MetricKind.ValueType  # 3
    """Minimize the value of the expression defined in the `expression` field"""
    MAXIMIZE_EXPRESSION_ON_FINAL_STATE: Metric.MetricKind.ValueType  # 4
    """Maximize the value of the expression defined in the `expression` field"""
    OVERSUBSCRIPTION: Metric.MetricKind.ValueType  # 5
    """Maximize the number of goals reached, weighted by cost"""

    @typing_extensions.final
    class ActionCostsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        @property
        def value(self) -> global___Expression: ...
        def __init__(
            self,
            *,
            key: builtins.str = ...,
            value: global___Expression | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["value", b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["key", b"key", "value", b"value"]) -> None: ...

    KIND_FIELD_NUMBER: builtins.int
    EXPRESSION_FIELD_NUMBER: builtins.int
    ACTION_COSTS_FIELD_NUMBER: builtins.int
    DEFAULT_ACTION_COST_FIELD_NUMBER: builtins.int
    GOALS_FIELD_NUMBER: builtins.int
    TIMED_GOALS_FIELD_NUMBER: builtins.int
    kind: global___Metric.MetricKind.ValueType
    @property
    def expression(self) -> global___Expression:
        """Expression to minimize/maximize in the final state.
        Empty, if the `kind` is not {MIN/MAX}IMIZE_EXPRESSION_ON_FINAL_STATE
        """
    @property
    def action_costs(self) -> google.protobuf.internal.containers.MessageMap[builtins.str, global___Expression]:
        """If `kind == MINIMIZE_ACTION_COSTS``, then each action is associated to a cost expression.

        TODO: Document what is allowed in the expression. See issue #134
        In particular, for this metric to be useful in many practical problems, the cost expression
        should allow referring to the action parameters (and possibly the current state at the action start/end).
        This is very awkward to do in this setting where the expression is detached from its scope.
        """
    @property
    def default_action_cost(self) -> global___Expression: ...
    @property
    def goals(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___GoalWithCost]:
        """List of goals used to define the oversubscription planning problem.
        Empty, if the `kind` is not OVERSUBSCRIPTION
        """
    @property
    def timed_goals(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___TimedGoalWithCost]: ...
    def __init__(
        self,
        *,
        kind: global___Metric.MetricKind.ValueType = ...,
        expression: global___Expression | None = ...,
        action_costs: collections.abc.Mapping[builtins.str, global___Expression] | None = ...,
        default_action_cost: global___Expression | None = ...,
        goals: collections.abc.Iterable[global___GoalWithCost] | None = ...,
        timed_goals: collections.abc.Iterable[global___TimedGoalWithCost] | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["default_action_cost", b"default_action_cost", "expression", b"expression"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["action_costs", b"action_costs", "default_action_cost", b"default_action_cost", "expression", b"expression", "goals", b"goals", "kind", b"kind", "timed_goals", b"timed_goals"]) -> None: ...

global___Metric = Metric

@typing_extensions.final
class Problem(google.protobuf.message.Message):
    """features: ACTION_BASED"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    DOMAIN_NAME_FIELD_NUMBER: builtins.int
    PROBLEM_NAME_FIELD_NUMBER: builtins.int
    TYPES_FIELD_NUMBER: builtins.int
    FLUENTS_FIELD_NUMBER: builtins.int
    OBJECTS_FIELD_NUMBER: builtins.int
    ACTIONS_FIELD_NUMBER: builtins.int
    INITIAL_STATE_FIELD_NUMBER: builtins.int
    TIMED_EFFECTS_FIELD_NUMBER: builtins.int
    GOALS_FIELD_NUMBER: builtins.int
    FEATURES_FIELD_NUMBER: builtins.int
    METRICS_FIELD_NUMBER: builtins.int
    HIERARCHY_FIELD_NUMBER: builtins.int
    domain_name: builtins.str
    problem_name: builtins.str
    @property
    def types(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___TypeDeclaration]: ...
    @property
    def fluents(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Fluent]: ...
    @property
    def objects(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ObjectDeclaration]: ...
    @property
    def actions(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Action]:
        """List of actions in the domain."""
    @property
    def initial_state(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Assignment]:
        """Initial state, including default values of state variables."""
    @property
    def timed_effects(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___TimedEffect]:
        """Facts and effects that are expected to occur strictly later than the initial state.
        features: TIMED_EFFECT
        """
    @property
    def goals(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Goal]:
        """Goals of the planning problem."""
    @property
    def features(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[global___Feature.ValueType]:
        """all features of the problem"""
    @property
    def metrics(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Metric]:
        """The plan quality metrics"""
    @property
    def hierarchy(self) -> global___Hierarchy:
        """If the problem is hierarchical, defines the tasks and methods as well as the initial task network.
        features: hierarchical
        """
    def __init__(
        self,
        *,
        domain_name: builtins.str = ...,
        problem_name: builtins.str = ...,
        types: collections.abc.Iterable[global___TypeDeclaration] | None = ...,
        fluents: collections.abc.Iterable[global___Fluent] | None = ...,
        objects: collections.abc.Iterable[global___ObjectDeclaration] | None = ...,
        actions: collections.abc.Iterable[global___Action] | None = ...,
        initial_state: collections.abc.Iterable[global___Assignment] | None = ...,
        timed_effects: collections.abc.Iterable[global___TimedEffect] | None = ...,
        goals: collections.abc.Iterable[global___Goal] | None = ...,
        features: collections.abc.Iterable[global___Feature.ValueType] | None = ...,
        metrics: collections.abc.Iterable[global___Metric] | None = ...,
        hierarchy: global___Hierarchy | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["hierarchy", b"hierarchy"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["actions", b"actions", "domain_name", b"domain_name", "features", b"features", "fluents", b"fluents", "goals", b"goals", "hierarchy", b"hierarchy", "initial_state", b"initial_state", "metrics", b"metrics", "objects", b"objects", "problem_name", b"problem_name", "timed_effects", b"timed_effects", "types", b"types"]) -> None: ...

global___Problem = Problem

@typing_extensions.final
class ActionInstance(google.protobuf.message.Message):
    """=================== Plan ================

    Representation of an action instance that appears in a plan.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ID_FIELD_NUMBER: builtins.int
    ACTION_NAME_FIELD_NUMBER: builtins.int
    PARAMETERS_FIELD_NUMBER: builtins.int
    START_TIME_FIELD_NUMBER: builtins.int
    END_TIME_FIELD_NUMBER: builtins.int
    id: builtins.str
    """Optional. A unique identifier of the action that might be used to refer to it (e.g. in HTN plans)."""
    action_name: builtins.str
    """name of the action"""
    @property
    def parameters(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Atom]:
        """Parameters of the action instance, required to be constants."""
    @property
    def start_time(self) -> global___Real:
        """Start time of the action. The default 0 value is OK in the case of non-temporal planning
        feature: [DURATIVE_ACTIONS]
        """
    @property
    def end_time(self) -> global___Real:
        """End time of the action. The default 0 value is OK in the case of non-temporal planning
        feature: [DURATIVE_ACTIONS]
        """
    def __init__(
        self,
        *,
        id: builtins.str = ...,
        action_name: builtins.str = ...,
        parameters: collections.abc.Iterable[global___Atom] | None = ...,
        start_time: global___Real | None = ...,
        end_time: global___Real | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["end_time", b"end_time", "start_time", b"start_time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["action_name", b"action_name", "end_time", b"end_time", "id", b"id", "parameters", b"parameters", "start_time", b"start_time"]) -> None: ...

global___ActionInstance = ActionInstance

@typing_extensions.final
class Plan(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ACTIONS_FIELD_NUMBER: builtins.int
    @property
    def actions(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ActionInstance]:
        """An ordered sequence of actions that appear in the plan.
        The order of the actions in the list must be compatible with the partial order of the start times.
        In case of non-temporal planning, this allows having all start time at 0 and only rely on the order in this sequence.
        """
    def __init__(
        self,
        *,
        actions: collections.abc.Iterable[global___ActionInstance] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["actions", b"actions"]) -> None: ...

global___Plan = Plan

@typing_extensions.final
class PlanRequest(google.protobuf.message.Message):
    """=============== RPC API ======================="""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _Mode:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _ModeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[PlanRequest._Mode.ValueType], builtins.type):  # noqa: F821
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        SATISFIABLE: PlanRequest._Mode.ValueType  # 0
        SOLVED_OPTIMALLY: PlanRequest._Mode.ValueType  # 1

    class Mode(_Mode, metaclass=_ModeEnumTypeWrapper): ...
    SATISFIABLE: PlanRequest.Mode.ValueType  # 0
    SOLVED_OPTIMALLY: PlanRequest.Mode.ValueType  # 1

    @typing_extensions.final
    class EngineOptionsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        value: builtins.str
        def __init__(
            self,
            *,
            key: builtins.str = ...,
            value: builtins.str = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key", b"key", "value", b"value"]) -> None: ...

    PROBLEM_FIELD_NUMBER: builtins.int
    RESOLUTION_MODE_FIELD_NUMBER: builtins.int
    TIMEOUT_FIELD_NUMBER: builtins.int
    ENGINE_OPTIONS_FIELD_NUMBER: builtins.int
    @property
    def problem(self) -> global___Problem:
        """Problem that should be solved."""
    resolution_mode: global___PlanRequest.Mode.ValueType
    timeout: builtins.float
    """Max allowed runtime time in seconds."""
    @property
    def engine_options(self) -> google.protobuf.internal.containers.ScalarMap[builtins.str, builtins.str]:
        """Engine specific options to be passed to the engine"""
    def __init__(
        self,
        *,
        problem: global___Problem | None = ...,
        resolution_mode: global___PlanRequest.Mode.ValueType = ...,
        timeout: builtins.float = ...,
        engine_options: collections.abc.Mapping[builtins.str, builtins.str] | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["problem", b"problem"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["engine_options", b"engine_options", "problem", b"problem", "resolution_mode", b"resolution_mode", "timeout", b"timeout"]) -> None: ...

global___PlanRequest = PlanRequest

@typing_extensions.final
class ValidationRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PROBLEM_FIELD_NUMBER: builtins.int
    PLAN_FIELD_NUMBER: builtins.int
    @property
    def problem(self) -> global___Problem:
        """Problem to be validated."""
    @property
    def plan(self) -> global___Plan:
        """Plan to validate."""
    def __init__(
        self,
        *,
        problem: global___Problem | None = ...,
        plan: global___Plan | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["plan", b"plan", "problem", b"problem"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["plan", b"plan", "problem", b"problem"]) -> None: ...

global___ValidationRequest = ValidationRequest

@typing_extensions.final
class LogMessage(google.protobuf.message.Message):
    """A freely formatted logging message.
    Each message is annotated with its criticality level from the minimal (DEBUG) to the maximal (ERROR).
    Criticality level is expected to be used by an end user to decide the level of verbosity.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _LogLevel:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _LogLevelEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[LogMessage._LogLevel.ValueType], builtins.type):  # noqa: F821
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        DEBUG: LogMessage._LogLevel.ValueType  # 0
        INFO: LogMessage._LogLevel.ValueType  # 1
        WARNING: LogMessage._LogLevel.ValueType  # 2
        ERROR: LogMessage._LogLevel.ValueType  # 3

    class LogLevel(_LogLevel, metaclass=_LogLevelEnumTypeWrapper): ...
    DEBUG: LogMessage.LogLevel.ValueType  # 0
    INFO: LogMessage.LogLevel.ValueType  # 1
    WARNING: LogMessage.LogLevel.ValueType  # 2
    ERROR: LogMessage.LogLevel.ValueType  # 3

    LEVEL_FIELD_NUMBER: builtins.int
    MESSAGE_FIELD_NUMBER: builtins.int
    level: global___LogMessage.LogLevel.ValueType
    message: builtins.str
    def __init__(
        self,
        *,
        level: global___LogMessage.LogLevel.ValueType = ...,
        message: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["level", b"level", "message", b"message"]) -> None: ...

global___LogMessage = LogMessage

@typing_extensions.final
class PlanGenerationResult(google.protobuf.message.Message):
    """Message sent by engine.
    Contains the engine exit status as well as the best plan found if any.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _Status:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _StatusEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[PlanGenerationResult._Status.ValueType], builtins.type):  # noqa: F821
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        SOLVED_SATISFICING: PlanGenerationResult._Status.ValueType  # 0
        """Valid plan found
        The `plan` field must be set.
        """
        SOLVED_OPTIMALLY: PlanGenerationResult._Status.ValueType  # 1
        """Plan found with optimality guarantee
        The `plan` field must be set and contains an optimal solution.
        """
        UNSOLVABLE_PROVEN: PlanGenerationResult._Status.ValueType  # 2
        """No plan exists"""
        UNSOLVABLE_INCOMPLETELY: PlanGenerationResult._Status.ValueType  # 3
        """The engine was not able to find a solution but does not give any guarantee that none exist
        (i.e. the engine might not be complete)
        """
        TIMEOUT: PlanGenerationResult._Status.ValueType  # 13
        """====== Engine exited before making any conclusion ====
        Search stopped before concluding SOLVED_OPTIMALLY or UNSOLVABLE_PROVEN
        If a plan was found, it might be reported in the `plan` field

        The engine ran out of time
        """
        MEMOUT: PlanGenerationResult._Status.ValueType  # 14
        """The engine ran out of memory"""
        INTERNAL_ERROR: PlanGenerationResult._Status.ValueType  # 15
        """The engine faced an internal error."""
        UNSUPPORTED_PROBLEM: PlanGenerationResult._Status.ValueType  # 16
        """The problem submitted is not supported by the engine."""
        INTERMEDIATE: PlanGenerationResult._Status.ValueType  # 17
        """====== Intermediate answer ======
        This Answer is an Intermediate Answer and not a Final one
        """

    class Status(_Status, metaclass=_StatusEnumTypeWrapper):
        """==== Engine stopped normally ======"""

    SOLVED_SATISFICING: PlanGenerationResult.Status.ValueType  # 0
    """Valid plan found
    The `plan` field must be set.
    """
    SOLVED_OPTIMALLY: PlanGenerationResult.Status.ValueType  # 1
    """Plan found with optimality guarantee
    The `plan` field must be set and contains an optimal solution.
    """
    UNSOLVABLE_PROVEN: PlanGenerationResult.Status.ValueType  # 2
    """No plan exists"""
    UNSOLVABLE_INCOMPLETELY: PlanGenerationResult.Status.ValueType  # 3
    """The engine was not able to find a solution but does not give any guarantee that none exist
    (i.e. the engine might not be complete)
    """
    TIMEOUT: PlanGenerationResult.Status.ValueType  # 13
    """====== Engine exited before making any conclusion ====
    Search stopped before concluding SOLVED_OPTIMALLY or UNSOLVABLE_PROVEN
    If a plan was found, it might be reported in the `plan` field

    The engine ran out of time
    """
    MEMOUT: PlanGenerationResult.Status.ValueType  # 14
    """The engine ran out of memory"""
    INTERNAL_ERROR: PlanGenerationResult.Status.ValueType  # 15
    """The engine faced an internal error."""
    UNSUPPORTED_PROBLEM: PlanGenerationResult.Status.ValueType  # 16
    """The problem submitted is not supported by the engine."""
    INTERMEDIATE: PlanGenerationResult.Status.ValueType  # 17
    """====== Intermediate answer ======
    This Answer is an Intermediate Answer and not a Final one
    """

    @typing_extensions.final
    class MetricsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        value: builtins.str
        def __init__(
            self,
            *,
            key: builtins.str = ...,
            value: builtins.str = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key", b"key", "value", b"value"]) -> None: ...

    STATUS_FIELD_NUMBER: builtins.int
    PLAN_FIELD_NUMBER: builtins.int
    METRICS_FIELD_NUMBER: builtins.int
    LOG_MESSAGES_FIELD_NUMBER: builtins.int
    ENGINE_FIELD_NUMBER: builtins.int
    status: global___PlanGenerationResult.Status.ValueType
    @property
    def plan(self) -> global___Plan:
        """Optional. Best plan found if any."""
    @property
    def metrics(self) -> google.protobuf.internal.containers.ScalarMap[builtins.str, builtins.str]:
        """A set of engine specific values that can be reported, for instance
        - "grounding-time": "10ms"
        - "expanded-states": "1290"
        """
    @property
    def log_messages(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___LogMessage]:
        """Optional log messages about the engine's activity.
        Note that it should not be expected that logging messages are visible to the end user.
        If used in conjunction with INTERNAL_ERROR or UNSUPPORTED_PROBLEM, it would be expected to have at least one log message at the ERROR level.
        """
    @property
    def engine(self) -> global___Engine:
        """Synthetic description of the engine that generated this message."""
    def __init__(
        self,
        *,
        status: global___PlanGenerationResult.Status.ValueType = ...,
        plan: global___Plan | None = ...,
        metrics: collections.abc.Mapping[builtins.str, builtins.str] | None = ...,
        log_messages: collections.abc.Iterable[global___LogMessage] | None = ...,
        engine: global___Engine | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["engine", b"engine", "plan", b"plan"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["engine", b"engine", "log_messages", b"log_messages", "metrics", b"metrics", "plan", b"plan", "status", b"status"]) -> None: ...

global___PlanGenerationResult = PlanGenerationResult

@typing_extensions.final
class Engine(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NAME_FIELD_NUMBER: builtins.int
    name: builtins.str
    """Short name of the engine (planner, validator, ...)"""
    def __init__(
        self,
        *,
        name: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["name", b"name"]) -> None: ...

global___Engine = Engine

@typing_extensions.final
class ValidationResult(google.protobuf.message.Message):
    """Message sent by the validator."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _ValidationResultStatus:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _ValidationResultStatusEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[ValidationResult._ValidationResultStatus.ValueType], builtins.type):  # noqa: F821
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        VALID: ValidationResult._ValidationResultStatus.ValueType  # 0
        """The Plan is valid for the Problem."""
        INVALID: ValidationResult._ValidationResultStatus.ValueType  # 1
        """The Plan is not valid for the Problem."""

    class ValidationResultStatus(_ValidationResultStatus, metaclass=_ValidationResultStatusEnumTypeWrapper): ...
    VALID: ValidationResult.ValidationResultStatus.ValueType  # 0
    """The Plan is valid for the Problem."""
    INVALID: ValidationResult.ValidationResultStatus.ValueType  # 1
    """The Plan is not valid for the Problem."""

    STATUS_FIELD_NUMBER: builtins.int
    LOG_MESSAGES_FIELD_NUMBER: builtins.int
    ENGINE_FIELD_NUMBER: builtins.int
    status: global___ValidationResult.ValidationResultStatus.ValueType
    @property
    def log_messages(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___LogMessage]:
        """Optional. Information given by the engine to the user."""
    @property
    def engine(self) -> global___Engine:
        """Synthetic description of the engine that generated this message."""
    def __init__(
        self,
        *,
        status: global___ValidationResult.ValidationResultStatus.ValueType = ...,
        log_messages: collections.abc.Iterable[global___LogMessage] | None = ...,
        engine: global___Engine | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["engine", b"engine"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["engine", b"engine", "log_messages", b"log_messages", "status", b"status"]) -> None: ...

global___ValidationResult = ValidationResult

@typing_extensions.final
class CompilerResult(google.protobuf.message.Message):
    """Message sent by the grounder."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing_extensions.final
    class MapBackPlanEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        @property
        def value(self) -> global___ActionInstance: ...
        def __init__(
            self,
            *,
            key: builtins.str = ...,
            value: global___ActionInstance | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["value", b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["key", b"key", "value", b"value"]) -> None: ...

    PROBLEM_FIELD_NUMBER: builtins.int
    MAP_BACK_PLAN_FIELD_NUMBER: builtins.int
    LOG_MESSAGES_FIELD_NUMBER: builtins.int
    ENGINE_FIELD_NUMBER: builtins.int
    @property
    def problem(self) -> global___Problem:
        """The problem generated by the Compiler"""
    @property
    def map_back_plan(self) -> google.protobuf.internal.containers.MessageMap[builtins.str, global___ActionInstance]:
        """The map_back_plan field is a map from the ActionInstance of the
        compiled problem to the original ActionInstance.
        """
    @property
    def log_messages(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___LogMessage]:
        """Optional. Information given by the engine to the user."""
    @property
    def engine(self) -> global___Engine:
        """Synthetic description of the engine that generated this message."""
    def __init__(
        self,
        *,
        problem: global___Problem | None = ...,
        map_back_plan: collections.abc.Mapping[builtins.str, global___ActionInstance] | None = ...,
        log_messages: collections.abc.Iterable[global___LogMessage] | None = ...,
        engine: global___Engine | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["engine", b"engine", "problem", b"problem"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["engine", b"engine", "log_messages", b"log_messages", "map_back_plan", b"map_back_plan", "problem", b"problem"]) -> None: ...

global___CompilerResult = CompilerResult
